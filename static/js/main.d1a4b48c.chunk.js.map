{"version":3,"sources":["Globe/useCountries.ts","Globe/Globe.tsx","App.tsx","index.tsx"],"names":["countries110m","a","fetch","cache","res","json","topology","countries","objects","feature","features","Error","useCountries","React","setCountries","status","setStatus","error","setError","getCountries","then","catch","Globe","size","rest","oceanColor","landColor","height","width","initialScale","center","rotateX","rotateY","rotateZ","rotation","dragSensitivity","minScroll","maxScroll","centerX","centerY","circleR","svgRef","projection","geoOrthographic","scale","rotate","translate","pathGenerator","geoPath","current","length","svg","select","countriesPaths","selectAll","globeCircle","countriesDataJoin","data","join","zoomBehaviour","zoom","on","event","scrollValue","transform","k","attr","dragBehaviour","drag","dx","dy","call","ref","fill","cx","cy","r","map","id","App","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.d1a4b48c.chunk.js","sourcesContent":["import * as React from 'react';\n\nimport { FeatureCollection } from 'geojson';\nimport { feature } from 'topojson-client';\nimport { Topology } from 'topojson-specification';\nimport { Feature as BaseFeature, GeoJsonProperties, Geometry } from 'geojson';\n\nexport type Feature = BaseFeature<Geometry, GeoJsonProperties>;\nexport type Features = Feature[];\n\n/**\n * A fixed version of World Atlas Countries 110m\n *\n * https://github.com/Fil/visionscarto-world-atlas\n */\nconst countries110m =\n  'https://unpkg.com/visionscarto-world-atlas@0.0.6/world/110m.json';\n\n/**\n * Gets TopoJSON data from CDN and transforms it to features that can be used to generate\n * the globe path.\n */\nasync function getCountries(): Promise<Features> {\n  const res = await fetch(countries110m, {\n    /**\n     * I'm just learning about caching, so I'm not 100% sure if this is a correct approach.\n     * World Atlas data is very likely never going to change, so I think that it can be safely\n     * always served from cache.\n     */\n    cache: 'force-cache',\n  });\n  const topology: Topology = await res.json();\n  const countries = topology.objects.countries;\n\n  if (countries) {\n    const { features } = feature(topology, countries) as FeatureCollection;\n\n    return features;\n  } else {\n    throw new Error(`There was no \"countries\" object in \"topology.objects\"`);\n  }\n}\n\ntype Status = 'idle' | 'pending' | 'resolved' | 'rejected';\n\nexport function useCountries() {\n  const [countries, setCountries] = React.useState<Features>([]);\n  const [status, setStatus] = React.useState<Status>('idle');\n  const [error, setError] = React.useState<Error | null>(null);\n\n  React.useEffect(() => {\n    setStatus('pending');\n\n    getCountries()\n      .then(countries => {\n        setStatus('resolved');\n        setCountries(countries);\n      })\n      .catch(error => {\n        setStatus('rejected');\n        setError(error);\n      });\n  }, []);\n\n  return { countries, status, error };\n}\n","import * as React from 'react';\nimport {\n  D3ZoomEvent,\n  geoOrthographic,\n  geoPath,\n  select,\n  zoom,\n  drag,\n  D3DragEvent,\n} from 'd3';\n\nimport { useCountries } from './useCountries';\n\nexport interface GlobeProps {\n  oceanColor?: string;\n  landColor?: string;\n\n  /**\n   * A shorthand for height and width of the SVG element\n   */\n  size?: number;\n\n  /**\n   * Height of the SVG\n   */\n  height?: number;\n\n  /**\n   * Width of the SVG\n   */\n  width?: number;\n\n  /**\n   *  Scale factor to be used for the projection\n   */\n  initialScale?: number;\n\n  /**\n   * A point specified as a two-dimensional array [longitude, latitude] in degrees.\n   * This will be the projectionâ€™s center.\n   */\n  center?: [number, number];\n\n  /**\n   * The x-axis rotation angle in degrees\n   */\n  rotateX?: number;\n\n  /**\n   * The y-axis rotation angle in degrees\n   */\n  rotateY?: number;\n\n  /**\n   * The z-axis rotation angle in degrees\n   */\n  rotateZ?: number;\n\n  /**\n   * Alternatively to separately specifying each rotation axis, you\n   * can provide them as an array [X,Y,Z]\n   */\n  rotation?: [number, number, number];\n\n  /**\n   * Drag sensitivity\n   */\n  dragSensitivity?: number;\n\n  /**\n   * Min scroll value\n   */\n  minScroll?: number;\n\n  /**\n   * Max scroll value\n   */\n  maxScroll?: number;\n}\n\nexport function Globe({ size = 400, ...rest }: GlobeProps) {\n  const {\n    oceanColor = '#eaedee',\n    landColor = '#17181d',\n    height = size,\n    width = size,\n    initialScale = size / 2,\n    center = [0, 0],\n    rotateX = 0,\n    rotateY = 0,\n    rotateZ = 0,\n    rotation = [rotateX, rotateY, rotateZ],\n    dragSensitivity = 75,\n    minScroll = 0.3,\n    maxScroll = 20,\n  } = rest;\n\n  // Variables\n\n  const centerX = width / 2;\n  const centerY = height / 2;\n  const circleR = initialScale;\n\n  // State\n\n  const svgRef = React.useRef<SVGSVGElement>(null);\n  const { countries } = useCountries();\n\n  // Projection\n  const projection = React.useMemo(\n    () =>\n      geoOrthographic()\n        .scale(initialScale)\n        .center(center)\n        .rotate(rotation)\n        .translate([centerX, centerY]),\n    [initialScale, center, rotation, centerX, centerY],\n  );\n\n  // Path generator\n  const pathGenerator = geoPath().projection(projection);\n\n  // Update `path` when `pathGenerator` changes\n  React.useEffect(() => {\n    if (svgRef.current && countries.length) {\n      interface SVGDatum {\n        width: number;\n        height: number;\n      }\n\n      interface PathDatum {\n        id: string;\n      }\n\n      const svg = select<SVGSVGElement, SVGDatum>(svgRef.current);\n      const countriesPaths = svg.selectAll<SVGPathElement, PathDatum>('path');\n      const globeCircle = svg.select<SVGCircleElement>('circle');\n\n      const countriesDataJoin = countriesPaths.data(countries).join('path');\n\n\n      /**\n       * Zoom behaviour\n       */\n      const zoomBehaviour = zoom<SVGSVGElement, SVGDatum>().on(\n        'zoom',\n        (event: D3ZoomEvent<SVGSVGElement, SVGDatum>) => {\n          let scrollValue = event.transform.k;\n\n          // Reached max/min zoom\n          if (scrollValue >= maxScroll) scrollValue = maxScroll;\n          if (scrollValue <= minScroll) scrollValue = minScroll;\n          else {\n            // Update projection\n            projection.scale(initialScale * scrollValue);\n\n            // Update path generator with new projection\n            pathGenerator.projection(projection);\n\n            // Update selectors\n            globeCircle.attr('r', projection.scale());\n            countriesDataJoin.attr('d', pathGenerator);\n          }\n        },\n      );\n\n      /**\n       * Drag behaviour\n       */\n      const dragBehaviour = drag<SVGSVGElement, SVGDatum>().on(\n        'drag',\n        (event: D3DragEvent<SVGSVGElement, SVGDatum, SVGDatum>) => {\n          const rotate = projection.rotate();\n          const k = dragSensitivity / projection.scale();\n\n          // Update projection\n          projection.rotate([\n            rotate[0] + event.dx * k,\n            rotate[1] - event.dy * k,\n          ]);\n\n          pathGenerator.projection(projection);\n          countriesDataJoin.attr('d', pathGenerator);\n        },\n      );\n\n      // Apply zoom behaviour\n      svg.call(dragBehaviour).call(zoomBehaviour);\n\n      globeCircle.attr('r', projection.scale());\n      countriesDataJoin.attr('d', pathGenerator);\n    }\n  }, [\n    initialScale,\n    maxScroll,\n    minScroll,\n    projection,\n    countries,\n    pathGenerator,\n    dragSensitivity,\n  ]);\n\n  return (\n    <svg ref={svgRef} width={width} height={height} fill={landColor}>\n      <circle cx={centerX} cy={centerY} r={circleR} fill={oceanColor} />\n      {countries.map(({ id }) => (\n        <path key={id} />\n      ))}\n    </svg>\n  );\n}\n","import { Globe } from \"./Globe/Globe\";\n\nfunction App() {\n  return (\n    <div>\n     <Globe width={200} height={200}/>\n     <Globe width={400} height={400}/>\n     <Globe width={800} height={800}/>\n    </div>\n  );\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n"],"sourceRoot":""}