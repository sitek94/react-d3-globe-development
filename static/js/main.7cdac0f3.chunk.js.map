{"version":3,"sources":["config.ts","use-countries/get-features.ts","use-countries/get-properties.ts","use-countries/get-countries.ts","use-countries/use-countries.ts","Globe/Globe.tsx","transformations/rotate-projection-to.ts","App.tsx","index.tsx"],"names":["defaults","duration","size","landColor","oceanColor","center","rotation","dragSensitivity","minScroll","maxScroll","countries110m","getFeatures","a","fetch","res","json","topology","countries","objects","feature","features","Error","countriesPropertiesUrl","notFoundCountry","id","name","position","getProperties","csv","then","data","map","row","latitude","longitude","Number","Promise","all","properties","mapPropertiesToFeatures","countryProperties","find","p","useCountries","React","setCountries","status","setStatus","error","setError","current","getCountries","catch","Globe","props","svgStyle","circleStyle","height","width","rotateX","rotateY","rotateZ","centerX","centerY","scale","circleRadius","svgRef","projection","geoOrthographic","rotate","translate","pathGenerator","geoPath","rotateTo","selection","currentRotation","nextRotation","r","interpolate","transition","attrTween","d","t","Math","pow","pathD","rotateProjectionTo","select","selectAll","length","svg","countriesPaths","globeCircle","countriesDataJoin","join","zoomBehaviour","zoom","on","event","scrollValue","transform","k","attr","dragBehaviour","drag","rotationX","rotationY","dx","dy","call","ref","style","fill","cx","cy","country","onClick","App","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.7cdac0f3.chunk.js","sourcesContent":["export const colors = {\n  lightGray: '#eaedee',\n  darkGray: '#17181d',\n};\n\nexport const defaults = {\n  duration: 1000,\n  size: 400,\n  landColor: colors.lightGray,\n  oceanColor: colors.darkGray,\n  center: [0, 0],\n  rotation: [0, -30],\n  dragSensitivity: 75,\n  minScroll: 0.3,\n  maxScroll: 20,\n};\n","import { FeatureCollection } from 'geojson';\nimport { feature } from 'topojson-client';\nimport { Topology } from 'topojson-specification';\nimport { Features } from '../types';\n\n/**\n * A fixed version of World Atlas Countries 110m\n *\n * https://github.com/Fil/visionscarto-world-atlas\n */\nconst countries110m =\n  'https://unpkg.com/visionscarto-world-atlas@0.0.6/world/110m.json';\n\n/**\n * Fetches TopoJSON data from CDN and transforms it to Feature Collection using \"feature\"\n * helper from topojson-client\n */\nexport async function getFeatures(): Promise<Features> {\n  const res = await fetch(countries110m);\n  const topology: Topology = await res.json();\n  const countries = topology.objects.countries;\n\n  if (countries) {\n    const { features } = feature(topology, countries) as FeatureCollection;\n\n    return features;\n  } else {\n    throw new Error(`There was no \"countries\" object in \"topology.objects\"`);\n  }\n}\n","import { csv } from 'd3';\nimport { CountriesProperties, CountryProperties, Rotation } from '../types';\n\n/**\n * Countries Properties CSV\n *\n * For each country in this dataset there is\n * - id - ISO code of the country (the same code that is used for ID by World Atlas)\n * - name\n * - latitude\n * - longitude\n */\nconst countriesPropertiesUrl =\n  'https://gist.githubusercontent.com/sitek94/d1c99f4b1936ad047602cc569d30db6b/raw/countries.csv';\n\ntype Columns = 'id' | 'name' | 'latitude' | 'longitude';\n\nconst bermudaTrianglePosition: Rotation = [\n  25.027684437991375, -70.99627570018042,\n];\n\n/**\n * This object is used in unlikely event when some field is missing from fetched CSV file.\n */\nexport const notFoundCountry: CountryProperties = {\n  id: 'unknown',\n  name: 'unknown',\n  position: bermudaTrianglePosition,\n};\n\n/**\n * Fetches the CSV file and transforms it\n */\nexport async function getProperties(): Promise<CountriesProperties> {\n  return csv<Columns>(countriesPropertiesUrl).then(data =>\n    data.map(row => {\n      const { id, name, latitude, longitude } = row;\n\n      // There are no missing fields in the dataset but just in case set\n      // default values\n      if (!id || !name || !latitude || !longitude) {\n        return notFoundCountry;\n      }\n\n      return {\n        id,\n        name,\n        position: [Number(latitude), Number(longitude)],\n      };\n    }),\n  );\n}\n","import { CountriesFeatures, CountriesProperties, Features } from '../types';\nimport { getFeatures } from './get-features';\nimport { getProperties, notFoundCountry } from './get-properties';\n\n/**\n * Fetches both countries features and properties and then extends the features\n * by mapping the properties to them.\n */\nexport async function getCountries(): Promise<CountriesFeatures> {\n  const [features, properties] = await Promise.all([\n    getFeatures(),\n    getProperties(),\n  ]);\n\n  return mapPropertiesToFeatures(properties, features);\n}\n\nfunction mapPropertiesToFeatures(\n  properties: CountriesProperties,\n  features: Features,\n) {\n  return features.map(feature => {\n    const countryProperties = properties.find(p => p.id === feature.id);\n\n    return {\n      ...feature,\n      properties: countryProperties || notFoundCountry,\n    };\n  });\n}\n","import * as React from 'react';\n\nimport { CountriesFeatures } from '../types';\nimport { getCountries } from './get-countries';\n\ntype Status = 'idle' | 'pending' | 'resolved' | 'rejected';\n\nexport function useCountries() {\n  const [countries, setCountries] = React.useState<CountriesFeatures>([]);\n  const [status, setStatus] = React.useState<Status>('idle');\n  const [error, setError] = React.useState<Error | null>(null);\n\n  React.useEffect(() => {\n    let current = true;\n\n    setStatus('pending');\n\n    getCountries()\n      .then(countries => {\n        if (current) {\n          setStatus('resolved');\n          setCountries(countries);\n        }\n      })\n      .catch(error => {\n        if (current) {\n          setStatus('rejected');\n          setError(error);\n        }\n      });\n\n    return () => {\n      current = false;\n    };\n  }, []);\n\n  return { countries, status, error };\n}\n","import * as React from 'react';\nimport {\n  D3ZoomEvent,\n  geoOrthographic,\n  geoPath,\n  select,\n  zoom,\n  drag,\n  D3DragEvent,\n} from 'd3';\n\nimport { defaults } from '../config';\nimport { CountryFeature, Rotation, SVGDatum } from '../types';\nimport { rotateProjectionTo } from '../transformations/rotate-projection-to';\nimport { useCountries } from '../use-countries/use-countries';\n\nexport interface GlobeProps {\n  svgStyle?: React.CSSProperties;\n  circleStyle?: React.CSSProperties;\n  oceanColor?: string;\n  landColor?: string;\n\n  /**\n   * A shorthand for height and width of the SVG element\n   */\n  size?: number;\n\n  /**\n   * Height of the SVG\n   */\n  height?: number;\n\n  /**\n   * Width of the SVG\n   */\n  width?: number;\n\n  /**\n   * The x-axis rotation angle in degrees\n   */\n  rotateX?: number;\n\n  /**\n   * The y-axis rotation angle in degrees\n   */\n  rotateY?: number;\n\n  /**\n   * The z-axis rotation angle in degrees\n   */\n  rotateZ?: number;\n\n  /**\n   * Alternatively to separately specifying each rotation axis, you\n   * can provide them as an array [X,Y,Z]\n   */\n  rotation?: Rotation;\n\n  /**\n   * Drag sensitivity\n   */\n  dragSensitivity?: number;\n\n  /**\n   * Min scroll value\n   */\n  minScroll?: number;\n\n  /**\n   * Max scroll value\n   */\n  maxScroll?: number;\n}\n\nfunction Globe(props: GlobeProps) {\n  const {\n    // Styles\n    oceanColor = defaults.oceanColor,\n    landColor = defaults.landColor,\n    svgStyle,\n    circleStyle,\n\n    // Size\n    size = defaults.size,\n    height = size,\n    width = size,\n\n    // Rotation\n    rotateX = 0,\n    rotateY = 0,\n    rotateZ = 0,\n    rotation = [rotateX, rotateY, rotateZ],\n\n    // Interactivity\n    dragSensitivity = 75,\n    minScroll = 0.3,\n    maxScroll = 20,\n  } = props;\n\n  // Helper variables\n  const centerX = width / 2;\n  const centerY = height / 2;\n  const scale = size / 2;\n  const circleRadius = scale;\n\n  // Root svg ref\n  const svgRef = React.useRef<SVGSVGElement>(null);\n\n  // Countries data\n  const { countries } = useCountries();\n\n  // Projection\n  const projection = React.useMemo(\n    () =>\n      geoOrthographic()\n        .scale(scale)\n        .center([0, 0])\n        .rotate(rotation)\n        .translate([centerX, centerY]),\n    [scale, rotation, centerX, centerY],\n  );\n\n  // Path generator\n  const pathGenerator = geoPath(projection);\n\n  // Update `path` when `pathGenerator` changes\n  React.useEffect(() => {\n    if (svgRef.current && countries.length) {\n      const svg = select<SVGSVGElement, SVGDatum>(svgRef.current);\n      const countriesPaths =\n        svg.selectAll<SVGPathElement, CountryFeature>('path');\n      const globeCircle = svg.select<SVGCircleElement>('circle');\n\n      const countriesDataJoin = countriesPaths.data(countries).join('path');\n\n      /**\n       * Zoom behaviour\n       */\n      const zoomBehaviour = zoom<SVGSVGElement, SVGDatum>().on(\n        'zoom',\n        (event: D3ZoomEvent<SVGSVGElement, SVGDatum>) => {\n          let scrollValue = event.transform.k;\n\n          // Reached max/min zoom\n          if (scrollValue >= maxScroll) scrollValue = maxScroll;\n          if (scrollValue <= minScroll) scrollValue = minScroll;\n          else {\n            // Update projection\n            projection.scale(scale * scrollValue);\n\n            // Update path generator with new projection\n            pathGenerator.projection(projection);\n\n            // Update selectors\n            globeCircle.attr('r', projection.scale());\n            countriesDataJoin.attr('d', pathGenerator);\n          }\n        },\n      );\n\n      /**\n       * Drag behaviour\n       */\n      const dragBehaviour = drag<SVGSVGElement, SVGDatum>().on(\n        'drag',\n        (event: D3DragEvent<SVGSVGElement, SVGDatum, SVGDatum>) => {\n          const [rotationX, rotationY] = projection.rotate();\n          const k = dragSensitivity / projection.scale();\n\n          // Update projection\n          projection.rotate([\n            rotationX + event.dx * k,\n            rotationY - event.dy * k,\n          ]);\n\n          pathGenerator.projection(projection);\n          countriesDataJoin.attr('d', pathGenerator);\n        },\n      );\n\n      // Apply zoom behaviour\n      svg.call(dragBehaviour).call(zoomBehaviour);\n\n      globeCircle.attr('r', projection.scale());\n      countriesDataJoin.attr('d', pathGenerator);\n    }\n  }, [\n    scale,\n    maxScroll,\n    minScroll,\n    projection,\n    countries,\n    pathGenerator,\n    dragSensitivity,\n  ]);\n\n  function rotateTo(rotation: Rotation) {\n    if (!svgRef.current) {\n      return;\n    }\n    const svg = select<SVGSVGElement, SVGDatum>(svgRef.current);\n    const countriesPaths =\n      svg.selectAll<SVGPathElement, CountryFeature>('path');\n\n    rotateProjectionTo({\n      selection: countriesPaths,\n      projection,\n      pathGenerator,\n      rotation,\n    });\n  }\n\n  return (\n    <svg\n      ref={svgRef}\n      width={width}\n      height={height}\n      style={{ fill: landColor, ...svgStyle }}\n    >\n      <style>\n        {`\n          path:hover {\n            fill: blue;\n          }\n        `}\n      </style>\n      <circle\n        cx={centerX}\n        cy={centerY}\n        r={circleRadius}\n        style={{ fill: oceanColor, ...circleStyle }}\n      />\n      {countries.map(country => (\n        <path\n          key={country.id}\n          onClick={() => rotateTo(country.properties.position)}\n        />\n      ))}\n    </svg>\n  );\n}\n\nexport { Globe };\n","import { interpolate } from 'd3';\nimport { defaults } from '../config';\nimport {\n  CountriesPathsSelection,\n  GlobePathGenerator,\n  GlobeProjection,\n  Rotation,\n} from '../types';\n\ninterface RotateProjectionToParams {\n  selection: CountriesPathsSelection;\n  projection: GlobeProjection;\n  pathGenerator: GlobePathGenerator;\n  rotation: Rotation;\n  duration?: number;\n}\n\n/**\n * A function that makes a transition from current projection.rotation to\n * given rotation\n */\nexport const rotateProjectionTo = ({\n  selection,\n  projection,\n  pathGenerator,\n  duration = defaults.duration,\n  rotation,\n}: RotateProjectionToParams) => {\n  // Store the current rotation value\n  const currentRotation = projection.rotate();\n\n  // Update path generator with new projection\n  pathGenerator.projection(projection);\n\n  // Set next rotation\n  const nextRotation = rotation;\n\n  // Create interpolator function - that will make the transition from\n  // current rotation to the next rotation\n  const r = interpolate(currentRotation, nextRotation);\n\n  // Update selection\n  selection\n    .transition()\n    .attrTween('d', d => t => {\n      projection.rotate(r(Math.pow(t, 0.33)));\n      pathGenerator.projection(projection);\n\n      // When interpolator returns null, Chrome throws errors for\n      // <path> with attribute d=\"null\"\n      const pathD = pathGenerator(d);\n      return pathD !== null ? pathD : '';\n    })\n    .duration(duration);\n};\n","// import { Globe } from './Globe/NewGlobe';\nimport { Globe } from './Globe/Globe';\n\nfunction App() {\n  return (\n    <div>\n      <Globe width={250} height={250} />\n      <Globe width={250} height={250} />\n      <Globe width={250} height={250} />\n      <Globe width={750} height={750} />\n    </div>\n  );\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n"],"sourceRoot":""}